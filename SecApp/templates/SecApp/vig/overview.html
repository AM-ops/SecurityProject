{% extends 'base.html' %}
{% block titleblock %}
  Overview
{% endblock %}

{% block bodyblock %}
<div class="container">
    <div class="container m-5 p-3" style="text-align: center;">
        <h2>Our Vigen&egrave;re Algorithm Implementation</h2>
    </div>

    <div class="container">
        <div class="container m-5 p-3" style="text-align: left;">
            <h4> Our Vigen&egrave;re algorithm implementation makes use of: </h4>
            <p>
                - a function to extend the user given key to match the message or file content's length.<br /><br />
            <p>
                <h4>The Algorithm Itself: </h4>
            <p>
                Our Vigen&egrave;re algorithm implementation works using calculations involving the ASCII values of the letters, and byte characters in a file's case, to apply the same effect of a
                Vigen&egrave;re Table. The encryption adds these values within modulo26 for text (also adding 65 as discussed below) and modulo256 for files while the decryption subtracts these values. 
                When it comes to the text "mode" of this algorithm, we have included a check to ensure that all characters that have the cipher applied are indeed letters. This is done by: <br/>
                -Before th algortithm takes place, we apply the ".upper()" to the text string to keep all chracters as capital letters,<br />
                -Setting an if statement that riggers if the ASCII value of a character is not within the capital letter values, <br/>
                -Immediately append ta to he array that will be returned. <br /><br />
                Wecould also do the same process above but with lower ase letters with ".lower()" if we so chose.

                <br /><br />
            </p>

            <h4>The Key Extender: </h4>
            <p>
                As with the "normal" and our implementation of the Vigen&egrave;re cipher algorithm, the user provided key mmust be repeated across the length of the message.
                This function does nothing if the key provided is the same length as the message. However, if the key is shorter, it it incrementally added onto itself 
                character-by-character until the right length is met. <br/>
                In the event that the message is shorter than the key, this function returns the origional key. Due to the way the encryption and decryption
                algortithms function, this will not matter as the loops within them are tied to message length and not key lenght.<br/><br />
            </p>

            <h4> The Logic Behind Using the Sums Taken in Modulo26 of ASCII Values in Place of a Vigen&egrave;re Table: </h4>
            <p>
                Using the image below it is clear with the two letters 'M' and 'H', the letter 'T' is produced through the Vigen&egrave;re cipher.
                The ASCII values for these are as follows: <br />
                'M' = 77 <br />
                'H' = 72 <br />
                'T' = 84 <br /><br />
                Now if we take 77 + 72, we get 149. <br />
                Taking 149(mod26) we get 19 <br />
                Adding 65 and 19 we get 84 (As 65 is the value of 'A' so that we arrive back at the ASCII values of capital letters)<br />
                We can then see that the value we get from these calculations, is the same as the ASCII value of 'T' => and with the chr() we can take this number and return the letter 'T'.
            </p>
            <img src="https://pages.mtu.edu/~shene/NSF-4/Tutorial/VIG/FIG-VIG-Table-EX-M.jpg" alt="Vigen&egrave;re Table" width="600" height="400">

            <div class="container m-5 p-3" style="text-align: left;">
                <h4> Our Vigen&egrave;re Table Legacy code: </h4>
                <p>
                    VignereTable = []*26<br />
                    alphabet  = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']<br />
                    addRow = []<br />

                    for i in range(0,26):
                </p>
                <p style="text-indent: 40px">for j in range(0,26):</p>
                <p style="text-indent: 80px"> k = i+j</p>
                <p style="text-indent: 80px">if k >= 26:</p>
                <p style="text-indent: 120px">k -= 26</p>
                <p style="text-indent: 80px">addRow.append(alphabet[k])</p>
                <p style="text-indent: 40px">VignereTable.append(addRow)</p>
                <p style="text-indent: 40px">addRow = []</p><br />


                <div class="container m-5 p-3" style="text-align: left;">
                    <h4> Aknowledgement: </h4>
                    <p>
                        The above image of the Vigen&egrave;re table was taken from a websie authored by <i>
                            Dr. C.-K. Shene a
                            professor in the Department of Computer Science at Michigan Technological University
                        </i> (circa. 2014) available at https://pages.mtu.edu/~shene/NSF-4/Tutorial/VIG/Vig-Base.html
                    </p>


                </div>
            </div>
        </div>
    </div>
</div>
    {% endblock %}
